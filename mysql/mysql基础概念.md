# 一、了解SQL

**数据库**是一个以某种有组织的方式储存的数据集合

**数据库**保存有组织的数据的容器（通常是一个文件或一组文件）

**表**： 某种特定类型数据的结构化清单

 	 不能把不同的清单放在同一个表中  

​	 每张表在同一个数据库中的名字是唯一的

**列**： 	表由列组成，列中储存着表中某部分的信息

**数据类型**：	所容许的数据的类型。每个表列都有相应的数据类型，它限制（或容许）该列中存储的数据

​			数据类型还帮助正确地排序数据，并在优化磁盘使用方面起重要作用

**行** ：	 表中的数据是按行储存的， 网格中垂直为列，水平为行

**备注：	**提到行（row）时称其为数据库记录(record)，这两个属于是可以互相替代的，但是，行才是正确

**主键：	** 一列或一组列，其值能够唯一区分表中每个行（**唯一表示表中每行的这个列（或这组列）成为主键**）

虽然，并不总是都需要主键，但大多数程序猿都应保证创建的每个表都具有一个主键，以便于以后的数据操纵和管理  			

​	**任意两行都不具有相同的的主键值，每个行都必须具有一个主键值（主键不能为NULL）**

**普遍认为的几个好习惯：**

​	**1，不更新主键列中的值**

​	**2，不重用主键列的值**

​	**3，不在主键列中使用可能会更改的值（列如，如果使用一个名字作为主键以标识某个供应商，当该供应商合并和更改其名字时，必须更改这个主键）**

**SQL：**是一种专门用来与数据库通信的语言

优点：	1，开放，使用所有数据库

​		2，SQL简单易学（全都是英文单词组成）

​		3，强有力，灵活的语言元素。

​	

# 二、MySQL简介

1，什么是MySQL

​	优点：1，免费使用

​		 2，性能快

​		3，可信赖，大公司都在用

​		4，简单

​	用户--------->>客户机--------->> 服务器--------------->>数据库

2，MySQL命令使用程序

​	可以直接在终端输入mysql就可以进入

​	个别需要输入

```
mysql -u root -p 
```

启动     -u 是用户登录    root 是用户名  -p 是使用密码登录  -h 服务器地址  -P 端口

​	用；结束

输入help或者\h获取帮助

quit或者exit



# 三、使用MySQL

1,连接

主机名：localhost  或者   127.0.0.1

端口：默认3306

用户名

密码

列如：数据库名字movie

切换数据库:

```
use movie
```

显示数据库:

```
show databases
```

显示所有的表:

```
show tables
```

选择当前数据库可用的表

```
show columus from 表名
```

或者

```
describe  表明
```

支持的其他语言

```
show status 显示服务器状态
show create database/table  显示创建特定数据库或表的mysql语句
show grants 显示安全权限
show errors/warnings 显示服务器错误或警告
```

```
show help 显示所有允许的show语句
```



# 四、检索数据

1，检索单列

```
select 列名 from 表
```

2，检索多列

```
select 列名，列名，列名 from 表名
```

3，检索所有

```
select * from 表名
```

4，检索不同的行

```
select distinct 列 from 表名
```

distinct 不能被部分使用，除非都不同否则所有行都将检索

5，限制结果

显示前数字个

```
select 列名 from 表名 limit 数字
```

显示从数字1开始，后面的数字2个

```
select 列名 from 表名 limit 数字1,数字2
或
select 列名 from 表名 limit 数字1 offset 数字2
```

检索的第一行是行0 不是行1

检索不够，直接返回能返回的行数

6，使用完全限定表名

```
select 表名.行名 from 表名
select 表名.行名 from 数据库.表名
```



# 五、排序检索数据

不加排序条件，直接检索出来的顺序是无序的。

单列排序

```
select 列名 from 表名 order by 列名
```

多列排序

```
select 列名1, 列名2 from 表名 order by 列名1, 列名2
```

先按列名1的排序，不同时，才开始排列名2

指定排序方向

默认是升序，加了desc变为降序

```
select 列名1, 列名2 from 表名 order by 列名1, 列名2 desc
```

需要的后列名后面加desc

用limit要加在最后

```
select 列名1, 列名2 from 表名 order by 列名1, 列名2 desc limit 数字
```



# 六、数据过滤

1，where子句

```
select 列名1 from 表名 where 列名1 = 数字 
```

order by 要位于where之后

```
= 等于
<> 不等于
!= 不等于
< 小于
<= 小于等于
> 大于
>= 大于等于
BETWEEN 在指定的两个值之间
```

```
select 列名，列名 from 表 where 列名 != 数字    这种只能用！=
```



# 七、数据过滤

1,and 操作符号

两个条件并列。

```
select 列1，列2 from 表 where 条件1 and 条件2
```

两个条件筛选。

每添一条过滤条件就要使用一个and

2，or操作符号

两个条件有一个成立就行

```
select 列1，列2，列3 from 表 where 条件1 or 条件2
```

3、计算次序

```
select 列1，列2，列3 from 表 where 条件1 or 条件2 and 条件3
```



```
select 列1，列2，列3 from 表 where (条件1 or 条件2) and 条件3
```

4、in操作符

```
select 列1，列2 from 表 where in (起点，终点) order by 列1
```

in和or的功能差不多的

5、not操作符

```
select 列1，列2 from 表 where not 条件
```

not可以和in 、between 和exists 



# 八、用通配符进行过滤

1，like后跟通配符匹配

%表示任何字符出现任意次数

```
select 列1，列2 from 表 where 列 like ' 部分字符%'
```

这里要区分大小写。

例如

```
'abc%'	abc开头
'%abc'	abc结尾
'a%b'	a开头，b结尾
'%ab%'	无论哪里有ab
```

**不能匹配NULL**

2、下划线通配符

_ 和%的用途是一样的。但是，_只能匹配单个字符

有几个_匹配多少个位置

```
select 列1，列2 from 表 where 列 like '_部分字符'
```

通配符比其他搜索所花的时间更长

1，不要过度使用通配符。

2，没必要的情况下，不要用在搜索的开始

3，确定通配符所在的位置，否则返回不是想要的数据



# 九、正则表达式进行搜索

1，regexp 类型

regexp正则表达式

regexp的用法和like一样，但是，like是整行，regexp是包括行内值

```
select 列1，列2 from 表 where 列 regexp '部分字符'
```



2，or 类型

两个中的任意一个符合

```
select 列1，列2 from 表 where 列 regexp '部分字符|部分字符'
```

还用几个加几个“|"分隔



3，匹配几个字符之一

[一组字符] 和|功能是一样的。

```
select 列1，列2 from 表 where 列 regexp '[部分字符部分字符]'
相当于
select 列1，列2 from 表 where 列 regexp '[部分字符|部分字符]'
```

结果是相同的，但是没有加[ ]，结果就不一样了

```
select 列1，列2 from 表 where 列 regexp '[^部分字符部分字符]'  #匹配非
```

4，匹配范围

```
[0-9]   [a-z]   [A-Z]  
```

不要哪个，单独的踢出来不写

5,特殊字符

```
select 列1，列2 from 表 where 列 regexp '\\.'
```

表示查找"."，'\\\'表示查找全部

```
\\f		换页
\\n 	换行
\\r 	回车
\\t		制表
\\v		纵向制表
```

**多数正则表达式是一个"\"，但是MySQL要求两个"\\\"**

6,匹配字符类

```
类 				说 明
[:alnum:] 任意字母和数字（同[a-zA-Z0-9]）
[:alpha:] 任意字符（同[a-zA-Z]）
[:blank:] 空格和制表（同[\\t]）
[:cntrl:] ASCII控制字符（ASCII 0到31和127）
[:digit:] 任意数字（同[0-9]）
[:graph:] 与[:print:]相同，但不包括空格
[:lower:] 任意小写字母（同[a-z]）
[:print:] 任意可打印字符
[:punct:] 既不在[:alnum:]又不在[:cntrl:]中的任意字符
[:space:] 包括空格在内的任意空白字符（同[\\f\\n\\r\\t\\v]）
[:upper:] 任意大写字母（同[A-Z]）
[:xdigit:] 任意十六进制数字（同[a-fA-F0-9]）
```

7，匹配多个实例

```
元 字 符 				说 明
* 					0个或多个匹配
+				 1个或多个匹配（等于{1,}）
? 				0个或1个匹配（等于{0,1}）
{n}				 指定数目的匹配
{n,} 			不少于指定数目的匹配
{n,m} 			匹配数目的范围（m不超过255）
```

8,定位符

```
^ 文本的开始
$ 文本的结尾
[[:<:]] 词的开始
[[:>:]] 词的结尾
```

开始

```
select 列1，列2 from 表 where 列 regexp '^[部分字符部分字符]'  
```



# 十、创建计算字段

1，计算字段

储存在数据库中的数据一般不是应用程序所需要的格式。

可以在SQL语句内完成转换和格式化处理，也可以在客户机上完成，但是，在数据库中完成比在客户机上完成快很多

2，拼接字段

将值链接在一起构成一个单值，在SQL的select中，可使用concat（）函数来拼接两个列

```
select concat(列名1，列名2) from 表名
```

可以去除空格

```
select concat(Trim(列名1)，Trim（列名2)） from 表名
```

RTrim()去除右空格，LTrim()去除左空格

3，使用别名

如果要查看结果可以，但是，一个未别名的列不能用于客户机应用中，因为客户机没有办法引用它。

我们别名as关键字赋予

```
select concat(列名1，列名2) as 别名 from 表名
```

别名，也叫导出列

4，执行计算

```
select 列1，列2，列1*列2 as 列名 from 表名
```



# 十一，使用数据处理函数

1，函数

代码是具有可移植性的。不同的DBMS上有SQL相差不大，但是函数的可移植性不强，不同的DBMS差异较大。

2，文本处理函数

```
select 列1，Upper(列1) as 列名 from 表
```



```
函 数		 说 明
Left() 		返回串左边的字符
Length()		 返回串的长度
Locate() 		找出串的一个子串
Lower() 		将串转换为小写
LTrim() 		去掉串左边的空格
Right()		 返回串右边的字符
RTrim() 		去掉串右边的空格
Soundex() 	返回串的SOUNDEX值
SubString()	 返回子串的字符
Upper()		 将串转换为大写
```



SOUNDEX需要做进一步的解释。SOUNDEX是一个将任何文本串转换为描述其语音表示的字母数字模式的算法。SOUNDEX考虑了类似的发音字符和音节，使得能对串进行发音比较而不是字母比较。虽然SOUNDEX不是SQL概念，但MySQL（就像多数DBMS一样）都提供对SOUNDEX的支持。

```
select 列1，列2 from 表 where soundex('列2')=soundex('搜索内容')
```

这里是发音相似搜索



3，日期和事件处理函数

常用的日期和事件处理函数

```
AddDate() 增加一个日期（天、周等）
AddTime() 增加一个时间（时、分等）
CurDate() 返回当前日期
CurTime() 返回当前时间
Date() 返回日期时间的日期部分
DateDiff() 计算两个日期之差
Date_Add() 高度灵活的日期运算函数
Date_Format() 返回一个格式化的日期或时间串
Day() 返回一个日期的天数部分
DayOfWeek() 对于一个日期，返回对应的星期几
Hour() 返回一个时间的小时部分
Minute() 返回一个时间的分钟部分
Month() 返回一个日期的月份部分
Now() 返回当前日期和时间
Second() 返回一个时间的秒部分
Time() 返回一个日期时间的时间部分
Year() 返回一个日期的年份部分
```



```
select 列1，列2 from 表 where data(列)='2005-09-01'
```

搜索本月所有的内容

```
select 列1，列2 from 表 where data(列) between '2018-09-01' and '2018-09-30'
```

或者

```
select 列1，列2 from 表 where year(列)=2018 and month(列)=9
```



4，数值处理函数

```
函 数 	说 明
Abs()	 	返回一个数的绝对值
Cos() 		返回一个角度的余弦
Exp()		 返回一个数的指数值
Mod()	 	返回除操作的余数
Pi() 		返回圆周率
Rand() 		返回一个随机数
Sin() 		返回一个角度的正弦
Sqrt() 		返回一个数的平方根
Tan() 		返回一个角度的正切
```





# 十二、汇总数据

1，聚集函数（运行在行组上，计算和返回单个值的函数）

有时候，我们只用检索总数据，不用具体检索出来，比如：

​	1，确定表中行数（或者满足某个条件或包含某个特定值的行数）

​	2，获得表中行组的和

​	3，找出表列（或所有行或某些特定的行）的最大值、最小值和平均值

```
函 数 		说 明
AVG() 		返回某列的平均值
COUNT() 	返回某列的行数
MAX() 		返回某列的最大值
MIN()		 返回某列的最小值
SUM()		 返回某列值之和
```

1.1 avg()

```
select avg(列名或者行名) as 新列名 from 表
```

使用列名作为函数参数给出，要获得多个列的平均值，必须使用多个avg

NULL：avg（）函数忽略列值为null的行

1.2，count（）函数

count(*)表中所有行进行计数，**不管表中包含是空值（NULL)还是非空值**

count(column)特定的行进行计数   **忽略NULL**

对所有：

```
select count(*) as 新名称 from 表
```

对列：

```
select count(列) as 新名称 from 表
```

1.3 min(),max()

最大最小值

```
select max/min(列) as 新列名 from 表
```

**自动忽略NULL**的行

如果是按特定的行，那么就是最后/最前(max/min)一行

1.4 sum()

```
select sum(行) as 新列名 from 表 where 条件
```

**自动忽略NULL**的行



2，聚集不同值

**distinct**这个只能MySQL 5 以上的版本，5以下版本不支持   all是默认参数，不指定distinct 假定为all

2.1 

```
selet avg(distinct 列) as 新列名 from 表 where 条件
```

只计算不同的值

如果指定列名，只能用count（），不能用count（*），不能用于计算或表达式

3，组合聚集函数

select 可根据需要包含多个聚集函数

```
select count(*) as 新列名 ,
	min(列名) as 新列名，
	max(列名) as 新列名，
	avg(列名) as 新列名，
from 表
```



# 十三，分组数据

1，创建分组

group by

```
select 列1 ，列 as 新列名 from 表 group by 列1 
```

**注意事项**：

​	·group by 可以包含任意数目的列

​	·group by中嵌套分组，最后数值全部取回，不能单个取回

​	·group by 子句每个列必须是检索列和有效表达式，子句后跟相同表达式，	不能使用别名

​	·除了聚集计算，每个列必须在group by子句中给出

​	·如果分组中有null，则作为分组返回，如果是多行，则分为一组

​	·group by 子句必须出现在where子句之后，order by之前



每个分组以及分组汇总级别的值

```
select 列1 ，列 as 新列名 from 表 group by 列1 with rollup    
```



2，过滤分组

having过滤分组，where只能过滤行。

having支持where的所有操作符

```
select 列1，列 as 新列名 from 表 group by 列 having 过滤条件
```

having和where并用

```
select 列1，列2 as 新列名 from 表 where 条件1 group by 列 having 条件2
```

3，分组和排序

```
	ORDER BY 					GROUP BY 
排序产生的输出 				分组行。但输出可能不是分组的顺序
任意列都可以使用（甚至				只可能使用选择列或表达式列，而且必须使用每个选择
非选择的列也可以使用）				列表达式
不一定需要 						如果与聚集函数一起使用列（或表达式），则必须使用
```

用group by 的子句用order by来排序的唯一方法

```
select 列1 列2 as 新列名 from 表 group by 列 having 条件 order by 列
```

4，select 顺序

```
子 句 		说 明 			是否必须使用
SELECT 		要返回的列或表达式 		是
FROM 		从中检索数据的表 		仅在从表选择数据时使用
WHERE		 行级过滤				 否
GROUP BY 		分组说明 		仅在按组计算聚集时使用
HAVING 			组级过滤 			否
ORDER BY 		输出排序顺序 			否
LIMIT			 要检索的行数			 否
```



# 十四、使用子查询

1，利用子查询过滤

简单查询

```
select 列 from 表 where 条件
```

子查询

```
select 列 from 表 where (select 列 from 表 where 条件)
```

子查询，没有限制，但是由于性能问题，不要过多。

使用子查询必须保证select和where子句相同的数目

子查询一般和in连用，但是也可以用，= 和 <>

2,作为计算字段使用子查询

````
select 列1 ，列2 ，(select 列 from 表 where 条件) as 新列名 from 表 order by 列
````

条件当中，必须匹配限定列名。

内查询快于外查询



# 十五、联结表

1，关系表

主键：能表示唯一的标识

外键：外键为某个表中的一列，它包含另一个表的主键值，定义了两个表之间的关系

关系型数据库比非关系型数据库可伸缩性强。

**可伸缩性**：能够是响应不断增加的工作量而不失败，设计良好的数据库或应用程序称之为可伸缩性好

2，为什么要使用联结

联结是一种机制，用来在一条select语句中关联表，因此称之为联结。



3，创建联结

简单创建

```
select 列1，列2，列3 from 表1，表2 where 表1主 =表2主 
```

4，笛卡尔积(又称为叉联结)

由没有联结条件的表关系返回的结果为笛卡尔积。检索出的行的数目将是第一个表中的行数乘以第二个表中的行数

```
select 列1，列2，列3 from 表1，表2
```

5，内部联结

基于两个表之间的相等测试称为 **等值联结**，也称为**内部联结**

```
select 列1，列2，列3 from 表1 inner join 表2 on 表1主=表2主
```

规范建议使用inner join 

6，联结多个表

```
select 列1，列2，列3 ，列4 from 表1，表2，表3 where 表1=表2 and 表1 =表3 
```

子查询可以用联结多个表的方式来实现。



# 十六、创建高级联结

1，使用表别名

别名：除了用于列名和计算字段外，还可以给表别名，主要因为：

​		1，缩短SQL语句

​			2，允许在单条SELECT语句中多次使用相同的表 

```
select 列1，列2 from 表1 as 新列名1 ，表2 as 新列名2 ，表3 as 新列名3 where 表1主 = 表2主 and 表1主 = 表3主 
```



2，使用不同类型的联结

2.1 自联结

使用相同的表

```
select 列1 ，列2 from 表1 where 列1 = （select 列3 from 表1 where 列1 = 某个值)
```

使用表别名的主要原因之一是能在单条SELECT语句中不 止一次引用相同的表。 

自联结

```
select p1.列1，p1.列2 from 表1 as p1 ，表1 as p2 where p1.列1 = p2.列1 and p2.列1=某个值
```

的第一次出现为别名p1 ，第二次出现为别名p2 。SELECT语 句使用p1前缀明确地给出所需列的全名 。即使它们事实上是同一个列 ，MySQL不知道想 要的是哪一个列 ，WHERE（通过匹配p1中 的列1和p2中的列1）首先联结两个表，然后按第二个表中的 列1过滤数据，返回所需的数据。 

**用自联结而不用子查询** 

有时候处理联结远比处理子查询快得多。 

2.2 自然联结

有一个列出现在不止一个表中 ,自然联结排除多次出现，使每个列只返回一次 

自然联结是这样一种联结，其中你只能选择那些唯一的列。这一 般是通过对表使用通配符（SELECT *），对所有其他表的列使用明确的子 集来完成的。 

```
select A.* ,B.列1，C.列2 from 表1 as A ，表2 as B ，表3 as C where 表1主 =表2主 and 表3主 = 表2主 and 条件
```

在这个例子中，通配符只对第一个表使用。所有其他列明确列 出，所以没有重复的列被检索出来。 

迄今为止我们建立的每个内部联结都是自然联结，很可能 我们永远都不会用到不是自然联结的内部联结。 

2.3 外部联结

许多联结将一个表中的行与另一个表中的行相关联 

```
select 表1.列1， 表2.列2 from 表1 left out join orders on 表1主=表2主
```

这条SELECT语句使用了关 键字OUTER JOIN来指定联结的类型（而不是在WHERE子句中指 定）。但是，与内部联结关联两个表中的行不同的是，外部联结还包括没 有关联行的行。在使用OUTER JOIN语法时，必须使用RIGHT或LEFT关键字 指定包括其所有行的表（RIGHT指出的是OUTER JOIN右边的表，而LEFT 指出的是OUTER JOIN左边的表）。上面的例子使用LEFT OUTER JOIN从FROM 子句的左边表（customers表）中选择所有行。为了从右边的表中选择所 有行，应该使用RIGHT OUTER JOIN 

```
select 表1.列1， 表2.列2 from 表2 left out join orders on 表1主=表2主
```



```
没有*=操作符 MySQL不支持简化字符*=和=*的使用，这两种操作符在其他DBMS中是很流行的。
```

它们之间的唯一差别是所关联的表的顺序不 同。 

究竟使用哪一种纯粹是根据方便而定。 

2.4 使用带聚集函数的联结 

虽然至今为止聚集函数 的所有例子只是从单个表汇总数据，但这些函数也可以与联结一起使用。 

```
select 表1.列1 ,表2.列2 from 表1 left out join 表2 on 表1主=表2主 
```



3. 注意所使用的联结类型。一般我们使用内部联结，但使用外部联 结也是有效的。

  保证使用正确的联结条件，否则将返回不正确的数据。 

 应该总是提供联结条件，否则会得出笛卡儿积。

  在一个联结中可以包含多个表，甚至对于每个联结可以采用不同 的联结类型。虽然这样做是合法的，一般也很有用，但应该在一 起测试它们前，分别测试每个联结。这将使故障排除更为简单 